---
title: "Covid by County: Interactive Map"
output:
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    theme: 
      version: 4
      bootswatch: lux
runtime: shiny
---
  
```{r setup, include=FALSE}
library(flexdashboard)
library(shiny)
library(leaflet)
library(dplyr)
library(tigris)
library(sf)
library(glue)
library(stringr)
library(RColorBrewer)
library(rmapshaper)

options(tigris_use_cache = TRUE)
options(tigris_class = "sf")

# Load cleaned datasets

covid_demo_final_df = readRDS("covid_demo_final_df.rds")
covid_rates         = readRDS("covid_yearly_rates.rds")

# Fix FIPS formatting
covid_demo_final_df = covid_demo_final_df |>
  mutate(fips = str_pad(fips, 5, pad = "0"))

covid_rates = covid_rates |>
  mutate(
    fips = str_pad(as.character(fips), 5, pad = "0"),
    year = as.numeric(year),
    fips = if_else(
      (is.na(fips) | fips == "000NA") & county == "New York City" & state == "New York",
      "36061",
      fips
    )
  ) |>
  filter(fips != "000NA", !grepl("^Unknown", county))
  
nyc_borough_fips = c("36005", "36047", "36061", "36081", "36085")

nyc_row <- covid_rates |> filter(fips == "36061")

# Duplicate for other boroughs
nyc_expanded = lapply(nyc_borough_fips, function(f) {
  nyc_row |> mutate(fips = f)
}) |> bind_rows()

# Remove any other NYC row & replace with 5-borough version
covid_rates = covid_rates |>
  filter(!(fips %in% nyc_borough_fips)) |>
  bind_rows(nyc_expanded)

# Add majority party and black population proportion

covid_demo_final_df = covid_demo_final_df |>
  mutate(
    majority_2016 = case_when(
      elections_2016_dem > elections_2016_gop ~ "Democrat",
      elections_2016_gop > elections_2016_dem ~ "Republican",
      TRUE ~ "Tie"
    ),
    majority_2020 = case_when(
      elections_2020_dem > elections_2020_gop ~ "Democrat",
      elections_2020_gop > elections_2020_dem ~ "Republican",
      TRUE ~ "Tie"
    ),
    black_prop = race_black_alone_male + race_black_alone_female
  )


if (file.exists("counties_sf_simplified.rds")) {

  # Cached version, faster
  counties_sf <- readRDS("counties_sf_simplified.rds")

} else {

  # Build from raw, this is slow but now itll only run once
  counties_sf_raw <- counties(cb = TRUE, year = 2020) |> 
    st_transform(4326) |>
    mutate(GEOID = str_pad(GEOID, 5, pad = "0")) |>
    dplyr::select(GEOID, NAME, geometry)  

  counties_sf <- rmapshaper::ms_simplify(
    counties_sf_raw,
    keep = 0.02,       
    keep_shapes = TRUE
  )

  saveRDS(counties_sf, "counties_sf_simplified.rds")
}

# Join county shapes with demographics

counties_joined = counties_sf |>
  left_join(covid_demo_final_df, by = c("GEOID" = "fips"))

# Precompute thresholds 

black_cutoff = quantile(counties_joined$black_prop, 0.75, na.rm = TRUE)
mask_cutoff  = quantile(counties_joined$high_mask_use, 0.75, na.rm = TRUE)

filtered_data = reactive({
  
  # Get COVID data for selected year
  covid_year = covid_rates |>
    filter(year == input$year) |>
    rename(
      covid_cases  = yearly_cases,
      covid_deaths = yearly_deaths
    )
  

  # Join counties + demographics + covid
  
  df = counties_joined |>
  left_join(covid_year, by = c("GEOID" = "fips")) |>
  mutate(
    covid_ratio = ifelse(
      covid_cases > 0,
      covid_deaths / covid_cases,
      NA_real_
    )
  )

  
  # Apply filter for factor type
  high_df = low_df <- df
  
  if (input$compare_type == "poverty") {
    high_df = df |> filter(poverty_rate > 15)
    low_df  = df |> filter(poverty_rate <= 15)
    
  } else if (input$compare_type == "race_black") {
    high_df = df |> filter(black_prop >= black_cutoff)
    low_df  = df |> filter(black_prop < black_cutoff)
    
  } else if (input$compare_type == "party") {
    maj_col = if (input$election_year == "2016") "majority_2016" else "majority_2020"
    high_df = df |> filter(.data[[maj_col]] == "Republican")
    low_df  = df |> filter(.data[[maj_col]] == "Democrat")
    
  } else if (input$compare_type == "mask_use") {
    high_df = df |> filter(high_mask_use >= mask_cutoff)
    low_df  = df |> filter(high_mask_use < mask_cutoff)
  }
  
  # Return BOTH groups
  list(high = high_df, low = low_df)
})

format_popup = function(df, compare_type, year) {
  df |>
    mutate(
      compare_line = dplyr::case_when(
          compare_type == "poverty" ~ glue("Poverty rate: {round(poverty_rate, 1)}%"),
          compare_type == "race_black" ~ glue("Black population share: {round(black_prop, 3)}"),
          compare_type == "mask_use"   ~ glue("Mask usage: {round(high_mask_use * 100, 1)}%"),
          compare_type == "party"       ~ "Political party comparison",  # optional, just a label
          TRUE ~ ""
      ),
      covid_cases_line  = glue("Yearly cases ({year}): {scales::comma(coalesce(covid_cases,0))}"),
      covid_deaths_line = glue("Yearly deaths ({year}): {scales::comma(coalesce(covid_deaths,0))}"),
      popup = glue("
        <strong>{NAME} County</strong><br>
        {compare_line}<br>
        {covid_cases_line}<br>
        {covid_deaths_line}<br>
      ")
    ) |>
    pull(popup)
}

```

Column {.sidebar}
-------------------------------------

### Compare Groups Across Time

```{r}
selectInput(
  inputId = "compare_type",
  label   = "Choose What to Compare:",
  choices = c(
    "Poverty (High vs Low)"                           = "poverty",
    "Proportion black population (high vs low)"       = "race_black",
    "Political Party Majority (Republican vs Democrat)" = "party",
    "Mask Usage (High vs Low)"                        = "mask_use"
  )
)

conditionalPanel(
  condition = "input.compare_type == 'party'",
  radioButtons(
    inputId = "election_year",
    label   = "Election Year:",
    choices = c("2016", "2020"),
    selected = "2020"
  )
)

sliderInput(
  inputId = "year",
  label   = "COVID Year:",
  min     = 2020,
  max     = 2023,
  value   = 2020,
  step    = 1,
  sep     = ""
)

radioButtons(
  inputId = "covid_metric",
  label   = "COVID Metric:",
  choices = c(
    "Cases"  = "cases",
    "Deaths" = "deaths",
    "Deaths / Cases (Severity)" = "ratio"
  ),
  selected = "cases"
)

```

<a href="https://kaveriuberoy.github.io/p8105_final_project/" class="btn btn-primary">
  ← Back to Website
</a>

Column
-------------------------------------

```{r}
renderText({
if (input$compare_type == "poverty") {
"High-Poverty Counties"
} else if (input$compare_type == "race_black") {
"Higher Black Population Share"
} else if (input$compare_type == "mask_use") {
"High Mask-use Counties"
} else if (input$compare_type == "party") {
paste(input$election_year, "Republican-Majority Counties")
} else {
"High group"
}
})
```

```{r}
renderLeaflet({
  df = filtered_data()$high
  
  # Decide which metric to map based on the button:
  metric = dplyr::case_when(
    input$covid_metric == "cases"  ~ "covid_cases",
    input$covid_metric == "deaths" ~ "covid_deaths",
    input$covid_metric == "ratio"  ~ "covid_ratio"
  )
  
  #clean and transform in to LOG10 so colors aren't skewed on map
  df = df |>
    mutate(
      fill_value_raw = suppressWarnings(as.numeric(.data[[metric]])),
      fill_value     = ifelse(is.na(fill_value_raw), NA_real_, fill_value_raw),
      fill_value_log = ifelse(is.na(fill_value), NA_real_, log10(fill_value + 1))
    )
  
    # Create color ranges that are applicable to each map
  if (metric == "covid_ratio") {
    year_max_raw <- max(df$covid_ratio, na.rm = TRUE)
  } else if (metric == "covid_cases") {
    year_max_raw <- max(
      covid_rates$yearly_cases[covid_rates$year == input$year],
      na.rm = TRUE
    )
  } else {
    year_max_raw <- max(
      covid_rates$yearly_deaths[covid_rates$year == input$year],
      na.rm = TRUE
    )
  }
  if (!is.finite(year_max_raw) || year_max_raw <= 0) year_max_raw <- 1
  
  # Define the domain for colors using this LOG10 year-specific range
  domain_vals = log10(c(0, year_max_raw) + 1)
  
  # Set Color palette:

  pal = colorNumeric(
    palette = if (metric == "covid_cases") {
        colorRampPalette(brewer.pal(9, "YlGn"))(9)
      } else if (metric == "covid_deaths") {
        colorRampPalette(brewer.pal(9, "PuRd"))(9)
      } else {    # <-- for severity ratio
        colorRampPalette(brewer.pal(9, "YlOrRd"))(9)
      },
    domain   = domain_vals,
    na.color = "#f0f0f0"
  )
  
  # leaflet map for the "high" group
  leaflet(df) |>
    # Set start view, to be consistent with other map
    setView(lng = -98.6, lat = 39.8, zoom = 4) |>
    # Add a light basemap as the background
    addProviderTiles("CartoDB.Positron") |>
    # Draw county polygons, colored by the log-transformed COVID metric
    addPolygons(
      fillColor   = pal(df$fill_value_log),                
      fillOpacity = 0.8,
      color       = "white",                              
      weight      = 0.4,
      stroke      = TRUE,
      popup       = format_popup(df, input$compare_type, input$year)
    ) 
})

```

Column
-------------------------------------

```{r}
renderText({
if (input$compare_type == "poverty") {
"Low-Poverty Counties"
} else if (input$compare_type == "race_black") {
"Lower Black Population Share"
} else if (input$compare_type == "mask_use") {
"Low Mask-Use Counties"
} else if (input$compare_type == "party") {
paste(input$election_year, "Democratic-Majority Counties")
} else {
"Low group"
}
})
```

```{r}
renderLeaflet({
  # "low" comparison group
  df = filtered_data()$low
  
  # Same metric selection logic as the high map
  metric = dplyr::case_when(
      input$covid_metric == "cases"  ~ "covid_cases",
      input$covid_metric == "deaths" ~ "covid_deaths",
      input$covid_metric == "ratio"  ~ "covid_ratio"
    )
  
  
  # Clean + transform the selected metric into Log10:
  df <- df |>
    mutate(
      fill_value_raw = suppressWarnings(as.numeric(.data[[metric]])),
      fill_value     = ifelse(is.na(fill_value_raw), NA_real_, fill_value_raw),
      fill_value_log = ifelse(is.na(fill_value), NA_real_, log10(fill_value + 1))
    )
  
  # Create legend ranges that are applicable to each map
  if (metric == "covid_ratio") {
    year_max_raw <- max(df$covid_ratio, na.rm = TRUE)
  } else if (metric == "covid_cases") {
    year_max_raw <- max(
      covid_rates$yearly_cases[covid_rates$year == input$year],
      na.rm = TRUE
    )
  } else {
    year_max_raw <- max(
      covid_rates$yearly_deaths[covid_rates$year == input$year],
      na.rm = TRUE
    )
  }
  if (!is.finite(year_max_raw) || year_max_raw <= 0) year_max_raw <- 1
  
  # Log-scale domain for the palette (same as in the high map)
  domain_vals <- log10(c(0, year_max_raw) + 1)
  
  pal = colorNumeric(
    palette = if (metric == "covid_cases") {
        colorRampPalette(brewer.pal(9, "YlGn"))(9)
      } else if (metric == "covid_deaths") {
        colorRampPalette(brewer.pal(9, "PuRd"))(9)
      } else {    # <-- for severity ratio
        colorRampPalette(brewer.pal(9, "YlOrRd"))(9)
      },
    domain   = domain_vals,
    na.color = "#f0f0f0"
  )
  
  # Build the leaflet map for the "low" group
  leaflet(df) |>
    # Same start view as high map
    setView(lng = -98.6, lat = 39.8, zoom = 4) |>
    addProviderTiles("CartoDB.Positron") |>
    # Draw county polygons for the low group with the same log-scale mapping
    addPolygons(
      fillColor   = pal(df$fill_value_log),
      fillOpacity = 0.8,
      color       = "white",
      weight      = 0.4,
      stroke      = TRUE,
      popup       = format_popup(df, input$compare_type, input$year)
    ) |>
    # Legend based on Log10 scale and max values:
    addLegend(
      position = "bottomright",
      colors = {
        min_log    <- domain_vals[1]
        max_log    <- domain_vals[2]
        breaks_log <- seq(min_log, max_log, length.out = 5)
        pal(breaks_log)
      },
      # fixing labels log as ratio makes the numbers too small. 
      labels = {
        breaks_log <- seq(domain_vals[1], domain_vals[2], length.out = 5)
        breaks_raw <- 10^breaks_log - 1
        
        if (metric == "covid_ratio") {
          sprintf("%.4f", breaks_raw)   # 4 decimal places
        } else {
          scales::comma(round(breaks_raw))  # keep deahts as before
        }
      },
      title = dplyr::case_when(
        metric == "covid_cases"  ~ "COVID Cases (Log10)",
        metric == "covid_deaths" ~ "COVID Deaths (Log10)",
        metric == "covid_ratio"  ~ "Deaths ÷ Cases"
      ),
      opacity = 0.8
    )
})


```
